
bpf_bpfel.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <target_search_cb>:
;                              struct target_search_cb_ctx *cb_ctx) {
       0:	r0 = 1
;   if (!value || !((const __u32 *)(value))[0])
       1:	if r3 == 0 goto +13 <LBB1_5>
       2:	r1 = *(u32 *)(r3 + 0)
       3:	if r1 == 0 goto +11 <LBB1_5>
       4:	r0 = 0
;   return ((a->in6_u.u6_addr64[0] == b->in6_u.u6_addr64[0]) &&
       5:	r1 = *(u64 *)(r3 + 0)
       6:	r5 = *(u64 *)(r4 + 0)
       7:	if r5 != r1 goto +7 <LBB1_5>
;           (a->in6_u.u6_addr64[1] == b->in6_u.u6_addr64[1]));
       8:	r1 = *(u64 *)(r3 + 8)
       9:	r3 = *(u64 *)(r4 + 8)
;   if (in6_addr_equal(&cb_ctx->needle, value)) {
      10:	if r3 != r1 goto +4 <LBB1_5>
      11:	r0 = 1
;     cb_ctx->found = true;
      12:	*(u8 *)(r4 + 20) = r0
;     cb_ctx->key   = *key;
      13:	r1 = *(u32 *)(r2 + 0)
      14:	*(u32 *)(r4 + 16) = r1

0000000000000078 <LBB1_5>:
; }
      15:	exit

Disassembly of section xdp/exceed2go:

0000000000000000 <exceed2go>:
; int exceed2go(struct xdp_md *ctx) {
       0:	r9 = r1
       1:	r7 = 2
;   void *data_end = (void *)(unsigned long)ctx->data_end;
       2:	r6 = *(u32 *)(r9 + 4)
;   void *data     = (void *)(unsigned long)ctx->data;
       3:	r2 = *(u32 *)(r9 + 0)
;   assert_boundary(eth, data_end, DEFAULT_ACTION);
       4:	r1 = r2
       5:	r1 += 14
       6:	if r1 > r6 goto +257 <LBB0_73>
;   assert_equal(eth->h_proto, bpf_htons(ETH_P_IPV6), DEFAULT_ACTION);
       7:	r1 = *(u16 *)(r2 + 12)
       8:	if r1 != 56710 goto +255 <LBB0_73>
       9:	*(u64 *)(r10 - 56) = r2
      10:	r1 = 0
      11:	*(u32 *)(r10 - 40) = r1
      12:	r2 = r10
      13:	r2 += -40
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      14:	r1 = 0 ll
      16:	call 1
;   if (likely(value)) {
      17:	if r0 == 0 goto +2 <LBB0_4>
      18:	r1 = 1
;     __sync_fetch_and_add(value, 1);
      19:	lock *(u32 *)(r0 + 0) += r1

00000000000000a0 <LBB0_4>:
      20:	r2 = *(u64 *)(r10 - 56)
;   assert_boundary(ipv6, data_end, DEFAULT_ACTION);
      21:	r8 = r2
      22:	r8 += 54
      23:	if r8 > r6 goto +240 <LBB0_73>
;   struct target_search_cb_ctx target = {.needle = ipv6->daddr, .found = false};
      24:	r1 = *(u64 *)(r2 + 46)
      25:	*(u64 *)(r10 - 32) = r1
      26:	r1 = *(u64 *)(r2 + 38)
      27:	*(u64 *)(r10 - 40) = r1
      28:	r1 = 0
      29:	*(u8 *)(r10 - 20) = r1
      30:	*(u32 *)(r10 - 24) = r1
      31:	r3 = r10
      32:	r3 += -40
;   bpf_for_each_map_elem(&exceed2go_addrs, target_search_cb, &target, 0);
      33:	r1 = 0 ll
      35:	r2 = 0 ll
      37:	r4 = 0
      38:	call 164
      39:	r7 = 2
;   assert_equal(target.found, true, DEFAULT_ACTION);
      40:	r1 = *(u8 *)(r10 - 20)
      41:	if r1 != 1 goto +222 <LBB0_73>
      42:	r7 = 1
      43:	*(u32 *)(r10 - 16) = r7
      44:	r2 = r10
      45:	r2 += -16
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      46:	r1 = 0 ll
      48:	call 1
;   if (likely(value)) {
      49:	if r0 == 0 goto +1 <LBB0_8>
;     __sync_fetch_and_add(value, 1);
      50:	lock *(u32 *)(r0 + 0) += r7

0000000000000198 <LBB0_8>:
;   __u32 hop_key = ipv6->hop_limit > 0 ? ipv6->hop_limit - 1 : 0;
      51:	r1 = *(u64 *)(r10 - 56)
      52:	r2 = *(u8 *)(r1 + 21)
      53:	r1 = 0
      54:	if r2 == 0 goto +2 <LBB0_10>
      55:	r2 += -1
      56:	r1 = r2

00000000000001c8 <LBB0_10>:
;   __u32 hop_key = ipv6->hop_limit > 0 ? ipv6->hop_limit - 1 : 0;
      57:	*(u32 *)(r10 - 44) = r1
      58:	r1 <<= 32
      59:	r1 >>= 32
;   if (target.key > hop_key)
      60:	r2 = *(u32 *)(r10 - 24)
      61:	if r1 >= r2 goto +8 <LBB0_13>
      62:	r2 = r10
      63:	r2 += -44
;     exceed_addr = bpf_map_lookup_elem(&exceed2go_addrs, &hop_key);
      64:	r1 = 0 ll
      66:	call 1
;   if (!exceed_addr || !(exceed_addr->in6_u.u6_addr32[0])) {
      67:	if r0 == 0 goto +2 <LBB0_13>
      68:	r1 = *(u32 *)(r0 + 0)
      69:	if r1 != 0 goto +196 <LBB0_46>

0000000000000230 <LBB0_13>:
      70:	r1 = 2
      71:	*(u64 *)(r10 - 64) = r1
      72:	r7 = *(u64 *)(r10 - 56)
;   assert_equal(ipv6->nexthdr, IPPROTO_ICMPV6, DEFAULT_ACTION);
      73:	r1 = *(u8 *)(r7 + 20)
      74:	if r1 != 58 goto +188 <LBB0_72>
      75:	r1 = 4
      76:	*(u32 *)(r10 - 16) = r1
      77:	r2 = r10
      78:	r2 += -16
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      79:	r1 = 0 ll
      81:	call 1
;   if (likely(value)) {
      82:	if r0 == 0 goto +2 <LBB0_16>
      83:	r1 = 1
;     __sync_fetch_and_add(value, 1);
      84:	lock *(u32 *)(r0 + 0) += r1

00000000000002a8 <LBB0_16>:
;   assert_boundary(icmp6, data_end, DEFAULT_ACTION);
      85:	r1 = r7
      86:	r1 += 62
      87:	if r1 > r6 goto +175 <LBB0_72>
;   assert_equal(icmp6->icmp6_type, ICMP6_ECHO_REQUEST, DEFAULT_ACTION);
      88:	r1 = *(u8 *)(r8 + 0)
      89:	if r1 != 128 goto +173 <LBB0_72>
;   assert_equal(icmp6->icmp6_code, 0, DEFAULT_ACTION);
      90:	r1 = *(u8 *)(r7 + 55)
      91:	if r1 != 0 goto +171 <LBB0_72>
      92:	r1 = 5
      93:	*(u32 *)(r10 - 16) = r1
      94:	r2 = r10
      95:	r2 += -16
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      96:	r1 = 0 ll
      98:	call 1
;   if (likely(value)) {
      99:	if r0 == 0 goto +2 <LBB0_21>
     100:	r1 = 1
;     __sync_fetch_and_add(value, 1);
     101:	lock *(u32 *)(r0 + 0) += r1

0000000000000330 <LBB0_21>:
;   sum = bpf_csum_diff(NULL, 0, (void *)&ipv6->saddr, 2 * IPV6_ALEN, sum);
     102:	r3 = r7
     103:	r3 += 22
     104:	r1 = 0
     105:	r2 = 0
     106:	*(u64 *)(r10 - 72) = r3
     107:	r4 = 32
     108:	r5 = 0
     109:	call 28
     110:	r1 = r0
     111:	r1 <<= 32
     112:	r1 >>= 32
;   sum = csum_add(sum, ((__u32)ipv6->payload_len) << 16);
     113:	r0 = *(u16 *)(r7 + 18)
     114:	r0 <<= 16
     115:	r0 <<= 32
     116:	r0 >>= 32
;   csum += addend;
     117:	r0 += r1
     118:	r3 = r0
     119:	r3 <<= 32
     120:	r3 >>= 32
     121:	r1 = 1
     122:	r2 = 1
     123:	if r3 != r0 goto +1 <LBB0_23>
     124:	r2 = 0

00000000000003e8 <LBB0_23>:
;   return csum + (csum < addend);
     125:	r0 += r2
     126:	r2 = r0
     127:	r2 <<= 32
     128:	r2 >>= 32
     129:	r3 = 3321888767 ll
     131:	if r2 > r3 goto +1 <LBB0_25>
     132:	r1 = 0

0000000000000428 <LBB0_25>:
     133:	r7 += 38
     134:	*(u64 *)(r10 - 80) = r7
;   csum += addend;
     135:	r0 += r1
     136:	r9 = 1024
;   return csum + (csum < addend);
     137:	r0 += 973078528
     138:	goto +4 <LBB0_26>

0000000000000458 <LBB0_32>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     139:	r1 &= 65535
     140:	r9 = r1
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     141:	if r1 > 4 goto +1 <LBB0_26>
     142:	goto +23 <LBB0_74>

0000000000000478 <LBB0_26>:
;     __u16 j = (i >= 512) ? 512 : i;
     143:	r4 = r9
     144:	r4 <<= 32
     145:	r4 >>= 32
     146:	r1 = 512
     147:	if r1 > r4 goto +1 <LBB0_28>
     148:	r4 = 512

00000000000004a8 <LBB0_28>:
;     if (likely(buf + j <= data_end)) {
     149:	r7 = r8
     150:	r7 += r4
     151:	if r7 > r6 goto +6 <LBB0_30>
;       sum = bpf_csum_diff(NULL, 0, buf, j, sum);
     152:	r1 = 0
     153:	r2 = 0
     154:	r3 = r8
     155:	r5 = r0
     156:	call 28
     157:	r8 = r7

00000000000004f0 <LBB0_30>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     158:	r1 = r9
     159:	r1 += 65024
     160:	r9 <<= 32
     161:	r9 >>= 32
     162:	if r9 > 512 goto -24 <LBB0_32>
     163:	r9 >>= 1
     164:	r1 = r9
     165:	goto -27 <LBB0_32>

0000000000000530 <LBB0_74>:
;   if (likely(buf + 4 <= data_end)) {
     166:	r1 = r8
     167:	r1 += 4
     168:	r7 = *(u64 *)(r10 - 56)
     169:	if r1 > r6 goto +13 <LBB0_36>
;   csum += addend;
     170:	r0 <<= 32
     171:	r0 >>= 32
;     sum = csum_add(sum, *(__be32 *)buf++);
     172:	r1 = *(u32 *)(r8 + 0)
;   csum += addend;
     173:	r1 += r0
     174:	r3 = r1
     175:	r3 <<= 32
     176:	r3 >>= 32
     177:	r2 = 1
     178:	if r3 != r1 goto +1 <LBB0_35>
     179:	r2 = 0

00000000000005a0 <LBB0_35>:
;   return csum + (csum < addend);
     180:	r1 += r2
;     sum = csum_add(sum, *(__be32 *)buf++);
     181:	r8 += 1
     182:	r0 = r1

00000000000005b8 <LBB0_36>:
     183:	r1 = 0
;   if (likely(buf + 2 <= data_end)) {
     184:	r2 = r8
     185:	r2 += 2
     186:	if r2 > r6 goto +2 <LBB0_38>
;     addend = *(__be16 *)buf++;
     187:	r1 = *(u16 *)(r8 + 0)
     188:	r8 += 1

00000000000005e8 <LBB0_38>:
;   if (likely(buf + 1 <= data_end)) {
     189:	r2 = r8
     190:	r2 += 1
     191:	if r2 > r6 goto +2 <LBB0_40>
;     addend += *(__u8 *)buf++;
     192:	r2 = *(u8 *)(r8 + 0)
     193:	r1 += r2

0000000000000610 <LBB0_40>:
;   csum += addend;
     194:	r0 <<= 32
     195:	r0 >>= 32
     196:	r1 += r0
     197:	r3 = r1
     198:	r3 <<= 32
     199:	r3 >>= 32
     200:	r2 = 1
     201:	if r3 != r1 goto +1 <LBB0_42>
     202:	r2 = 0

0000000000000658 <LBB0_42>:
;   return csum + (csum < addend);
     203:	r1 += r2
     204:	r2 = 4294901760 ll
;   return csum + (csum < addend);
     206:	r3 = r1
     207:	r3 &= r2
;   sum = (sum & 0xffff) + (sum >> 16);
     208:	r1 &= 65535
     209:	r3 >>= 16
     210:	r1 += r3
;   sum = (sum & 0xffff) + (sum >> 16);
     211:	r2 = r1
     212:	r2 >>= 16
     213:	r2 += r1
;   assert_equal(csum_fold(icmp6_csum(icmp6, ipv6, data_end, false)),
     214:	r2 &= 65535
     215:	if r2 != 65535 goto +47 <LBB0_72>
     216:	r1 = 6
     217:	*(u32 *)(r10 - 16) = r1
     218:	r2 = r10
     219:	r2 += -16
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
     220:	r1 = 0 ll
     222:	call 1
;   if (likely(value)) {
     223:	if r0 == 0 goto +2 <LBB0_45>
     224:	r1 = 1
;     __sync_fetch_and_add(value, 1);
     225:	lock *(u32 *)(r0 + 0) += r1

0000000000000710 <LBB0_45>:
     226:	r1 = 96
;   bpf_memcpy(ipv6, &ipv6_new, sizeof(struct ipv6hdr) - 2 * IPV6_ALEN);
     227:	*(u32 *)(r7 + 14) = r1
     228:	r1 = 16442
     229:	*(u16 *)(r7 + 20) = r1
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     230:	r1 = *(u16 *)(r7 + 10)
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     231:	r2 = *(u16 *)(r7 + 4)
     232:	*(u16 *)(r7 + 10) = r2
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     233:	*(u16 *)(r7 + 4) = r1
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     234:	r1 = *(u16 *)(r7 + 0)
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     235:	r2 = *(u16 *)(r7 + 6)
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     236:	*(u16 *)(r7 + 0) = r2
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     237:	r2 = *(u16 *)(r7 + 2)
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     238:	r3 = *(u16 *)(r7 + 8)
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     239:	*(u16 *)(r7 + 2) = r3
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     240:	*(u16 *)(r7 + 6) = r1
     241:	*(u16 *)(r7 + 8) = r2
     242:	r2 = *(u64 *)(r10 - 72)
;   struct in6_addr tmpipv6addr = ipv6->saddr;
     243:	r1 = *(u64 *)(r2 + 8)
     244:	*(u64 *)(r10 - 8) = r1
     245:	r1 = *(u64 *)(r2 + 0)
     246:	*(u64 *)(r10 - 16) = r1
     247:	r3 = *(u64 *)(r10 - 80)
;   ipv6->saddr                 = ipv6->daddr;
     248:	r1 = *(u64 *)(r3 + 8)
     249:	*(u64 *)(r2 + 8) = r1
     250:	r1 = *(u64 *)(r3 + 0)
     251:	*(u64 *)(r2 + 0) = r1
;   ipv6->daddr                 = tmpipv6addr;
     252:	r1 = *(u64 *)(r10 - 8)
     253:	*(u64 *)(r3 + 8) = r1
     254:	r1 = *(u64 *)(r10 - 16)
     255:	*(u64 *)(r3 + 0) = r1
     256:	r1 = 129
;   icmp6->icmp6_type = ICMP6_ECHO_REPLY;
     257:	*(u16 *)(r7 + 54) = r1
;   icmp6->icmp6_cksum += ICMP6_ECHO_REQUEST - ICMP6_ECHO_REPLY;
     258:	r1 = *(u16 *)(r7 + 56)
     259:	r1 += -1
     260:	*(u16 *)(r7 + 56) = r1

0000000000000828 <LBB0_71>:
     261:	r1 = 3
     262:	*(u64 *)(r10 - 64) = r1

0000000000000838 <LBB0_72>:
     263:	r7 = *(u64 *)(r10 - 64)

0000000000000840 <LBB0_73>:
; }
     264:	r0 = r7
     265:	exit

0000000000000850 <LBB0_46>:
     266:	*(u64 *)(r10 - 56) = r0
     267:	r1 = 2
     268:	*(u32 *)(r10 - 16) = r1
     269:	r2 = r10
     270:	r2 += -16
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
     271:	r1 = 0 ll
     273:	call 1
;   if (likely(value)) {
     274:	if r0 == 0 goto +2 <LBB0_48>
     275:	r1 = 1
;     __sync_fetch_and_add(value, 1);
     276:	lock *(u32 *)(r0 + 0) += r1

00000000000008a8 <LBB0_48>:
;   void *data     = (void *)(unsigned long)ctx->data;
     277:	r2 = *(u32 *)(r9 + 0)
;   void *data_end = (void *)(unsigned long)ctx->data_end;
     278:	r1 = *(u32 *)(r9 + 4)
;   __u16 ip_pkt_len      = ADJ_LEN + (data_end - data) - ETH_HLEN;
     279:	r1 -= r2
     280:	r1 += 34
;   int   tail_len_adjust = IPV6_MTU_MIN - ip_pkt_len;
     281:	r2 = r1
     282:	r2 &= 65535
     283:	r7 = 1280
     284:	r7 -= r2
;   if (tail_len_adjust > 0 && ip_pkt_len % 4) {
     285:	if r2 > 1279 goto +4 <LBB0_51>
     286:	r1 &= 3
     287:	if r1 == 0 goto +2 <LBB0_51>
;     tail_len_adjust = -(ip_pkt_len % 4);
     288:	r1 = -r1
     289:	r7 = r1

0000000000000910 <LBB0_51>:
;   assert_equal(bpf_xdp_adjust_head(ctx, head_len_adjust), 0, XDP_ABORTED);
     290:	r1 = r9
     291:	r2 = 4294967248 ll
     293:	call 44
     294:	r1 = 0
;   assert_equal(bpf_xdp_adjust_head(ctx, head_len_adjust), 0, XDP_ABORTED);
     295:	*(u64 *)(r10 - 64) = r1
     296:	if r0 != 0 goto -34 <LBB0_72>
;   if (tail_len_adjust < 0)
     297:	if r7 s> -1 goto +4 <LBB0_54>
;     assert_equal(bpf_xdp_adjust_tail(ctx, tail_len_adjust), 0, XDP_ABORTED);
     298:	r1 = r9
     299:	r2 = r7
     300:	call 65
     301:	if r0 != 0 goto -39 <LBB0_72>

0000000000000970 <LBB0_54>:
;   data_end = (void *)(unsigned long)ctx->data_end;
     302:	r8 = *(u32 *)(r9 + 4)
;   data     = (void *)(unsigned long)ctx->data;
     303:	r6 = *(u32 *)(r9 + 0)
;   assert_boundary(orig_ipv6, data_end, XDP_ABORTED);
     304:	r1 = r6
     305:	r1 += 102
     306:	if r1 > r8 goto -44 <LBB0_72>
     307:	r1 = 96
;   bpf_memcpy(ipv6, &ipv6_new, sizeof(struct ipv6hdr) - 2 * IPV6_ALEN);
     308:	*(u32 *)(r6 + 14) = r1
     309:	r1 = 0
     310:	*(u8 *)(r6 + 18) = r1
     311:	*(u8 *)(r6 + 19) = r1
;   struct icmp6hdr *icmp6 = next_header(ipv6);
     312:	r7 = r6
     313:	r7 += 54
;   ipv6->payload_len = bpf_htons(data_end - (void *)icmp6);
     314:	r2 = r8
     315:	r2 -= r7
     316:	r2 = be16 r2
     317:	*(u16 *)(r6 + 18) = r2
     318:	r2 = 16442
;   bpf_memcpy(ipv6, &ipv6_new, sizeof(struct ipv6hdr) - 2 * IPV6_ALEN);
     319:	*(u16 *)(r6 + 20) = r2
;   eth->h_proto = orig_eth->h_proto;
     320:	r2 = *(u16 *)(r6 + 60)
     321:	*(u16 *)(r6 + 12) = r2
;   bpf_memcpy(&eth->h_dest, &orig_eth->h_source, ETH_ALEN);
     322:	r2 = *(u16 *)(r6 + 58)
     323:	*(u16 *)(r6 + 4) = r2
     324:	r2 = *(u16 *)(r6 + 56)
     325:	*(u16 *)(r6 + 2) = r2
     326:	r2 = *(u16 *)(r6 + 54)
     327:	*(u16 *)(r6 + 0) = r2
;   bpf_memcpy(&eth->h_source, &orig_eth->h_dest, ETH_ALEN);
     328:	r2 = *(u16 *)(r6 + 52)
     329:	*(u16 *)(r6 + 10) = r2
     330:	r2 = *(u16 *)(r6 + 50)
     331:	*(u16 *)(r6 + 8) = r2
     332:	r2 = *(u16 *)(r6 + 48)
     333:	*(u16 *)(r6 + 6) = r2
     334:	r3 = *(u64 *)(r10 - 56)
;   ipv6->saddr       = *src_addr;
     335:	r2 = *(u64 *)(r3 + 8)
     336:	*(u64 *)(r6 + 30) = r2
     337:	r2 = *(u64 *)(r3 + 0)
     338:	*(u64 *)(r6 + 22) = r2
     339:	r2 = 3
;   bpf_memcpy(icmp6, &icmp6_new, sizeof(struct icmp6hdr));
     340:	*(u32 *)(r6 + 54) = r2
;   ipv6->daddr       = orig_ipv6->saddr;
     341:	r2 = *(u64 *)(r6 + 78)
     342:	*(u64 *)(r6 + 46) = r2
     343:	r2 = *(u64 *)(r6 + 70)
     344:	*(u64 *)(r6 + 38) = r2
;   bpf_memcpy(icmp6, &icmp6_new, sizeof(struct icmp6hdr));
     345:	*(u32 *)(r6 + 58) = r1
;   ipv6->saddr       = *src_addr;
     346:	r3 = r6
     347:	r3 += 22
;   sum = bpf_csum_diff(NULL, 0, (void *)&ipv6->saddr, 2 * IPV6_ALEN, sum);
     348:	r1 = 0
     349:	r2 = 0
     350:	r4 = 32
     351:	r5 = 0
     352:	call 28
     353:	r1 = r0
     354:	r1 <<= 32
     355:	r1 >>= 32
;   sum = csum_add(sum, ((__u32)ipv6->payload_len) << 16);
     356:	r0 = *(u16 *)(r6 + 18)
     357:	r0 <<= 16
     358:	r0 <<= 32
     359:	r0 >>= 32
;   csum += addend;
     360:	r0 += r1
     361:	r3 = r0
     362:	r3 <<= 32
     363:	r3 >>= 32
     364:	r1 = 1
     365:	r2 = 1
     366:	if r3 != r0 goto +1 <LBB0_57>
     367:	r2 = 0

0000000000000b80 <LBB0_57>:
     368:	*(u64 *)(r10 - 56) = r6
;   return csum + (csum < addend);
     369:	r0 += r2
     370:	r2 = r0
     371:	r2 <<= 32
     372:	r2 >>= 32
     373:	r3 = 3321888767 ll
     375:	if r2 > r3 goto +1 <LBB0_59>
     376:	r1 = 0

0000000000000bc8 <LBB0_59>:
;   csum += addend;
     377:	r0 += r1
     378:	r9 = 1024
;   return csum + (csum < addend);
     379:	r0 += 973078528
     380:	goto +4 <LBB0_60>

0000000000000be8 <LBB0_66>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     381:	r1 &= 65535
     382:	r9 = r1
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     383:	if r1 > 4 goto +1 <LBB0_60>
     384:	goto +23 <LBB0_75>

0000000000000c08 <LBB0_60>:
;     __u16 j = (i >= 512) ? 512 : i;
     385:	r4 = r9
     386:	r4 <<= 32
     387:	r4 >>= 32
     388:	r1 = 512
     389:	if r1 > r4 goto +1 <LBB0_62>
     390:	r4 = 512

0000000000000c38 <LBB0_62>:
;     if (likely(buf + j <= data_end)) {
     391:	r6 = r7
     392:	r6 += r4
     393:	if r6 > r8 goto +6 <LBB0_64>
;       sum = bpf_csum_diff(NULL, 0, buf, j, sum);
     394:	r1 = 0
     395:	r2 = 0
     396:	r3 = r7
     397:	r5 = r0
     398:	call 28
     399:	r7 = r6

0000000000000c80 <LBB0_64>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     400:	r1 = r9
     401:	r1 += 65024
     402:	r9 <<= 32
     403:	r9 >>= 32
     404:	if r9 > 512 goto -24 <LBB0_66>
     405:	r9 >>= 1
     406:	r1 = r9
     407:	goto -27 <LBB0_66>

0000000000000cc0 <LBB0_75>:
;   if (likely(buf + 4 <= data_end)) {
     408:	r1 = r7
     409:	r1 += 4
     410:	r4 = *(u64 *)(r10 - 56)
     411:	if r1 > r8 goto +12 <LBB0_70>
;     sum = csum_add(sum, *(__be32 *)buf++);
     412:	r1 = *(u32 *)(r7 + 0)
;   csum += addend;
     413:	r0 <<= 32
     414:	r0 >>= 32
     415:	r1 += r0
     416:	r3 = r1
     417:	r3 <<= 32
     418:	r3 >>= 32
     419:	r2 = 1
     420:	if r3 != r1 goto +1 <LBB0_69>
     421:	r2 = 0

0000000000000d30 <LBB0_69>:
;   return csum + (csum < addend);
     422:	r1 += r2
     423:	r0 = r1

0000000000000d40 <LBB0_70>:
     424:	r1 = 4294901760 ll
;   sum = (sum & 0xffff) + (sum >> 16);
     426:	r2 = r0
     427:	r2 &= r1
     428:	r2 >>= 16
     429:	r0 &= 65535
     430:	r0 += r2
;   sum = (sum & 0xffff) + (sum >> 16);
     431:	r1 = r0
     432:	r1 >>= 16
     433:	r1 += r0
;   icmp6->icmp6_cksum = ~csum_fold(icmp6_csum(icmp6, ipv6, data_end, true));
     434:	r1 ^= -1
     435:	*(u16 *)(r4 + 56) = r1
     436:	goto -176 <LBB0_71>
