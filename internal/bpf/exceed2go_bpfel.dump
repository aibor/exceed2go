
exceed2go_bpfel.o:	file format elf64-bpf

Disassembly of section .text:

0000000000000000 <target_search_cb>:
;                              struct target_search_cb_ctx *cb_ctx) {
       0:	r0 = 0x0
;   if (*key == 0) {
       1:	r1 = *(u32 *)(r2 + 0x0)
       2:	if r1 == 0x0 goto +0xe <LBB1_6>
       3:	r0 = 0x1
;   if (!value || !((const __u32 *)(value))[0])
       4:	if r3 == 0x0 goto +0xc <LBB1_6>
       5:	r2 = *(u32 *)(r3 + 0x0)
       6:	if r2 == 0x0 goto +0xa <LBB1_6>
;   return ((a->in6_u.u6_addr64[0] == b->in6_u.u6_addr64[0]) &&
       7:	r2 = *(u64 *)(r3 + 0x0)
       8:	r5 = *(u64 *)(r4 + 0x0)
       9:	r0 = 0x0
      10:	if r5 != r2 goto +0x6 <LBB1_6>
;           (a->in6_u.u6_addr64[1] == b->in6_u.u6_addr64[1]));
      11:	r2 = *(u64 *)(r3 + 0x8)
      12:	r3 = *(u64 *)(r4 + 0x8)
;   if (in6_addr_equal(&cb_ctx->needle, value)) {
      13:	if r3 != r2 goto +0x3 <LBB1_6>
;     cb_ctx->key   = *key;
      14:	*(u32 *)(r4 + 0x10) = r1
      15:	r0 = 0x1
;     cb_ctx->found = true;
      16:	*(u8 *)(r4 + 0x14) = r0

0000000000000088 <LBB1_6>:
; }
      17:	exit

Disassembly of section xdp/exceed2go:

0000000000000000 <exceed2go>:
; int exceed2go(struct xdp_md *ctx) {
       0:	r9 = r1
       1:	r7 = 0x2
;   void *data_end = (void *)(unsigned long)ctx->data_end;
       2:	r6 = *(u32 *)(r9 + 0x4)
;   void *data     = (void *)(unsigned long)ctx->data;
       3:	r2 = *(u32 *)(r9 + 0x0)
;   assert_boundary(eth, data_end, DEFAULT_ACTION);
       4:	r1 = r2
       5:	r1 += 0xe
       6:	if r1 > r6 goto +0xfb <LBB0_71>
;   assert_equal(eth->h_proto, bpf_htons(ETH_P_IPV6), DEFAULT_ACTION);
       7:	r1 = *(u16 *)(r2 + 0xc)
       8:	if r1 != 0xdd86 goto +0xf9 <LBB0_71>
       9:	*(u64 *)(r10 - 0x38) = r2
      10:	r1 = 0x0
      11:	*(u32 *)(r10 - 0x28) = r1
      12:	r2 = r10
      13:	r2 += -0x28
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      14:	r1 = 0x0 ll
      16:	call 0x1
;   if (likely(value)) {
      17:	if r0 == 0x0 goto +0x2 <LBB0_4>
      18:	r1 = 0x1
;     __sync_fetch_and_add(value, 1);
      19:	lock *(u32 *)(r0 + 0x0) += r1

00000000000000a0 <LBB0_4>:
      20:	r2 = *(u64 *)(r10 - 0x38)
;   assert_boundary(ipv6, data_end, DEFAULT_ACTION);
      21:	r8 = r2
      22:	r8 += 0x36
      23:	if r8 > r6 goto +0xea <LBB0_71>
;   struct target_search_cb_ctx target = {.needle = ipv6->daddr, .found = false};
      24:	r1 = *(u64 *)(r2 + 0x2e)
      25:	*(u64 *)(r10 - 0x20) = r1
      26:	r1 = *(u64 *)(r2 + 0x26)
      27:	*(u64 *)(r10 - 0x28) = r1
      28:	r1 = 0x0
      29:	*(u8 *)(r10 - 0x14) = r1
      30:	*(u32 *)(r10 - 0x18) = r1
      31:	r3 = r10
      32:	r3 += -0x28
;   bpf_for_each_map_elem(&exceed2go_addrs, target_search_cb, &target, 0);
      33:	r1 = 0x0 ll
      35:	r2 = 0x0 ll
      37:	r4 = 0x0
      38:	call 0xa4
;   assert_equal(target.found, true, DEFAULT_ACTION);
      39:	r1 = *(u8 *)(r10 - 0x14)
      40:	if r1 == 0x0 goto +0xd9 <LBB0_71>
      41:	r7 = 0x1
      42:	*(u32 *)(r10 - 0x10) = r7
      43:	r2 = r10
      44:	r2 += -0x10
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      45:	r1 = 0x0 ll
      47:	call 0x1
;   if (likely(value)) {
      48:	if r0 == 0x0 goto +0x1 <LBB0_8>
;     __sync_fetch_and_add(value, 1);
      49:	lock *(u32 *)(r0 + 0x0) += r7

0000000000000190 <LBB0_8>:
;   __u32            hop_key     = ipv6->hop_limit;
      50:	r1 = *(u64 *)(r10 - 0x38)
      51:	r1 = *(u8 *)(r1 + 0x15)
      52:	*(u32 *)(r10 - 0x2c) = r1
;   if (target.key > hop_key)
      53:	r2 = *(u32 *)(r10 - 0x18)
      54:	if r1 >= r2 goto +0x8 <LBB0_11>
      55:	r2 = r10
      56:	r2 += -0x2c
;     exceed_addr = bpf_map_lookup_elem(&exceed2go_addrs, &hop_key);
      57:	r1 = 0x0 ll
      59:	call 0x1
;   if (!exceed_addr || !(exceed_addr->in6_u.u6_addr32[0])) {
      60:	if r0 == 0x0 goto +0x2 <LBB0_11>
      61:	r1 = *(u32 *)(r0 + 0x0)
      62:	if r1 != 0x0 goto +0xc5 <LBB0_44>

00000000000001f8 <LBB0_11>:
      63:	r1 = 0x2
      64:	*(u64 *)(r10 - 0x40) = r1
      65:	r7 = *(u64 *)(r10 - 0x38)
;   assert_equal(ipv6->nexthdr, IPPROTO_ICMPV6, DEFAULT_ACTION);
      66:	r1 = *(u8 *)(r7 + 0x14)
      67:	if r1 != 0x3a goto +0xbd <LBB0_70>
      68:	r1 = 0x3
      69:	*(u32 *)(r10 - 0x10) = r1
      70:	r2 = r10
      71:	r2 += -0x10
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      72:	r1 = 0x0 ll
      74:	call 0x1
;   if (likely(value)) {
      75:	if r0 == 0x0 goto +0x2 <LBB0_14>
      76:	r1 = 0x1
;     __sync_fetch_and_add(value, 1);
      77:	lock *(u32 *)(r0 + 0x0) += r1

0000000000000270 <LBB0_14>:
;   assert_boundary(icmp6, data_end, DEFAULT_ACTION);
      78:	r1 = r7
      79:	r1 += 0x3e
      80:	if r1 > r6 goto +0xb0 <LBB0_70>
;   assert_equal(icmp6->icmp6_type, ICMP6_ECHO_REQUEST, DEFAULT_ACTION);
      81:	r1 = *(u8 *)(r8 + 0x0)
      82:	if r1 != 0x80 goto +0xae <LBB0_70>
;   assert_equal(icmp6->icmp6_code, 0, DEFAULT_ACTION);
      83:	r1 = *(u8 *)(r7 + 0x37)
      84:	if r1 != 0x0 goto +0xac <LBB0_70>
      85:	r1 = 0x4
      86:	*(u32 *)(r10 - 0x10) = r1
      87:	r2 = r10
      88:	r2 += -0x10
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
      89:	r1 = 0x0 ll
      91:	call 0x1
;   if (likely(value)) {
      92:	if r0 == 0x0 goto +0x2 <LBB0_19>
      93:	r1 = 0x1
;     __sync_fetch_and_add(value, 1);
      94:	lock *(u32 *)(r0 + 0x0) += r1

00000000000002f8 <LBB0_19>:
;   sum = bpf_csum_diff(NULL, 0, (void *)&ipv6->saddr, 2 * IPV6_ALEN, sum);
      95:	r3 = r7
      96:	r3 += 0x16
      97:	r1 = 0x0
      98:	r2 = 0x0
      99:	*(u64 *)(r10 - 0x48) = r3
     100:	r4 = 0x20
     101:	r5 = 0x0
     102:	call 0x1c
     103:	r1 = r0
     104:	r1 <<= 0x20
     105:	r1 >>= 0x20
;   sum = csum_add(sum, ((__u32)ipv6->payload_len) << 16);
     106:	r0 = *(u16 *)(r7 + 0x12)
     107:	r0 <<= 0x10
     108:	r0 <<= 0x20
     109:	r0 >>= 0x20
;   csum += addend;
     110:	r0 += r1
     111:	r3 = r0
     112:	r3 <<= 0x20
     113:	r3 >>= 0x20
     114:	r1 = 0x1
     115:	r2 = 0x1
     116:	if r3 != r0 goto +0x1 <LBB0_21>
     117:	r2 = 0x0

00000000000003b0 <LBB0_21>:
;   return csum + (csum < addend);
     118:	r0 += r2
     119:	r2 = r0
     120:	r2 <<= 0x20
     121:	r2 >>= 0x20
     122:	r3 = 0xc5ffffff ll
     124:	if r2 > r3 goto +0x1 <LBB0_23>
     125:	r1 = 0x0

00000000000003f0 <LBB0_23>:
     126:	r7 += 0x26
     127:	*(u64 *)(r10 - 0x50) = r7
;   csum += addend;
     128:	r0 += r1
     129:	r9 = 0x400
;   return csum + (csum < addend);
     130:	r0 += 0x3a000000
     131:	goto +0x4 <LBB0_24>

0000000000000420 <LBB0_30>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     132:	r1 &= 0xffff
     133:	r9 = r1
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     134:	if r1 > 0x4 goto +0x1 <LBB0_24>
     135:	goto +0x18 <LBB0_72>

0000000000000440 <LBB0_24>:
;     __u16 j = (i >= 512) ? 512 : i;
     136:	r4 = r9
     137:	r4 <<= 0x20
     138:	r4 >>= 0x20
     139:	r1 = 0x200
     140:	if r1 > r4 goto +0x1 <LBB0_26>
     141:	r4 = 0x200

0000000000000470 <LBB0_26>:
;     if (likely(buf + j <= data_end)) {
     142:	r7 = r8
     143:	r7 += r4
     144:	if r7 > r6 goto +0x6 <LBB0_28>
;       sum = bpf_csum_diff(NULL, 0, buf, j, sum);
     145:	r1 = 0x0
     146:	r2 = 0x0
     147:	r3 = r8
     148:	r5 = r0
     149:	call 0x1c
     150:	r8 = r7

00000000000004b8 <LBB0_28>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     151:	r1 = r9
     152:	r1 += 0xfe00
     153:	r2 = r9
     154:	r2 <<= 0x20
     155:	r2 >>= 0x20
     156:	if r2 > 0x200 goto -0x19 <LBB0_30>
     157:	r9 >>= 0x1
     158:	r1 = r9
     159:	goto -0x1c <LBB0_30>

0000000000000500 <LBB0_72>:
;   if (likely(buf + 4 <= data_end)) {
     160:	r1 = r8
     161:	r1 += 0x4
     162:	r7 = *(u64 *)(r10 - 0x38)
     163:	if r1 > r6 goto +0xd <LBB0_34>
;   csum += addend;
     164:	r0 <<= 0x20
     165:	r0 >>= 0x20
;     sum = csum_add(sum, *(__be32 *)buf++);
     166:	r1 = *(u32 *)(r8 + 0x0)
;   csum += addend;
     167:	r1 += r0
     168:	r3 = r1
     169:	r3 <<= 0x20
     170:	r3 >>= 0x20
     171:	r2 = 0x1
     172:	if r3 != r1 goto +0x1 <LBB0_33>
     173:	r2 = 0x0

0000000000000570 <LBB0_33>:
;   return csum + (csum < addend);
     174:	r1 += r2
;     sum = csum_add(sum, *(__be32 *)buf++);
     175:	r8 += 0x1
     176:	r0 = r1

0000000000000588 <LBB0_34>:
     177:	r1 = 0x0
;   if (likely(buf + 2 <= data_end)) {
     178:	r2 = r8
     179:	r2 += 0x2
     180:	if r2 > r6 goto +0x2 <LBB0_36>
;     addend = *(__be16 *)buf++;
     181:	r1 = *(u16 *)(r8 + 0x0)
     182:	r8 += 0x1

00000000000005b8 <LBB0_36>:
;   if (likely(buf + 1 <= data_end)) {
     183:	r2 = r8
     184:	r2 += 0x1
     185:	if r2 > r6 goto +0x2 <LBB0_38>
;     addend += *(__u8 *)buf++;
     186:	r2 = *(u8 *)(r8 + 0x0)
     187:	r1 += r2

00000000000005e0 <LBB0_38>:
;   csum += addend;
     188:	r0 <<= 0x20
     189:	r0 >>= 0x20
     190:	r1 += r0
     191:	r3 = r1
     192:	r3 <<= 0x20
     193:	r3 >>= 0x20
     194:	r2 = 0x1
     195:	if r3 != r1 goto +0x1 <LBB0_40>
     196:	r2 = 0x0

0000000000000628 <LBB0_40>:
;   return csum + (csum < addend);
     197:	r1 += r2
     198:	r2 = 0xffff0000 ll
;   return csum + (csum < addend);
     200:	r3 = r1
     201:	r3 &= r2
;   sum = (sum & 0xffff) + (sum >> 16);
     202:	r1 &= 0xffff
     203:	r3 >>= 0x10
     204:	r1 += r3
;   sum = (sum & 0xffff) + (sum >> 16);
     205:	r2 = r1
     206:	r2 >>= 0x10
     207:	r2 += r1
;   assert_equal(csum_fold(icmp6_csum(icmp6, ipv6, data_end, false)),
     208:	r2 &= 0xffff
     209:	if r2 != 0xffff goto +0x2f <LBB0_70>
     210:	r1 = 0x5
     211:	*(u32 *)(r10 - 0x10) = r1
     212:	r2 = r10
     213:	r2 += -0x10
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
     214:	r1 = 0x0 ll
     216:	call 0x1
;   if (likely(value)) {
     217:	if r0 == 0x0 goto +0x2 <LBB0_43>
     218:	r1 = 0x1
;     __sync_fetch_and_add(value, 1);
     219:	lock *(u32 *)(r0 + 0x0) += r1

00000000000006e0 <LBB0_43>:
     220:	r1 = 0x60
;   bpf_memcpy(ipv6, &ipv6_new, sizeof(struct ipv6hdr) - 2 * IPV6_ALEN);
     221:	*(u32 *)(r7 + 0xe) = r1
     222:	r1 = 0x403a
     223:	*(u16 *)(r7 + 0x14) = r1
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     224:	r1 = *(u16 *)(r7 + 0xa)
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     225:	r2 = *(u16 *)(r7 + 0x4)
     226:	*(u16 *)(r7 + 0xa) = r2
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     227:	*(u16 *)(r7 + 0x4) = r1
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     228:	r1 = *(u16 *)(r7 + 0x0)
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     229:	r2 = *(u16 *)(r7 + 0x6)
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     230:	*(u16 *)(r7 + 0x0) = r2
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     231:	r2 = *(u16 *)(r7 + 0x2)
;   bpf_memcpy(&tmphwaddr, &eth->h_source, ETH_ALEN);
     232:	r3 = *(u16 *)(r7 + 0x8)
;   bpf_memcpy(&eth->h_dest, &tmphwaddr, ETH_ALEN);
     233:	*(u16 *)(r7 + 0x2) = r3
;   bpf_memcpy(&eth->h_source, &eth->h_dest, ETH_ALEN);
     234:	*(u16 *)(r7 + 0x6) = r1
     235:	*(u16 *)(r7 + 0x8) = r2
     236:	r2 = *(u64 *)(r10 - 0x48)
;   struct in6_addr tmpipv6addr = ipv6->saddr;
     237:	r1 = *(u64 *)(r2 + 0x8)
     238:	*(u64 *)(r10 - 0x8) = r1
     239:	r1 = *(u64 *)(r2 + 0x0)
     240:	*(u64 *)(r10 - 0x10) = r1
     241:	r3 = *(u64 *)(r10 - 0x50)
;   ipv6->saddr                 = ipv6->daddr;
     242:	r1 = *(u64 *)(r3 + 0x8)
     243:	*(u64 *)(r2 + 0x8) = r1
     244:	r1 = *(u64 *)(r3 + 0x0)
     245:	*(u64 *)(r2 + 0x0) = r1
;   ipv6->daddr                 = tmpipv6addr;
     246:	r1 = *(u64 *)(r10 - 0x8)
     247:	*(u64 *)(r3 + 0x8) = r1
     248:	r1 = *(u64 *)(r10 - 0x10)
     249:	*(u64 *)(r3 + 0x0) = r1
     250:	r1 = 0x81
;   icmp6->icmp6_type = ICMP6_ECHO_REPLY;
     251:	*(u16 *)(r7 + 0x36) = r1
;   icmp6->icmp6_cksum += ICMP6_ECHO_REQUEST - ICMP6_ECHO_REPLY;
     252:	r1 = *(u16 *)(r7 + 0x38)
     253:	r1 += -0x1
     254:	*(u16 *)(r7 + 0x38) = r1

00000000000007f8 <LBB0_69>:
     255:	r1 = 0x3
     256:	*(u64 *)(r10 - 0x40) = r1

0000000000000808 <LBB0_70>:
     257:	r7 = *(u64 *)(r10 - 0x40)

0000000000000810 <LBB0_71>:
; }
     258:	r0 = r7
     259:	exit

0000000000000820 <LBB0_44>:
     260:	*(u64 *)(r10 - 0x38) = r0
     261:	r1 = 0x2
     262:	*(u32 *)(r10 - 0x10) = r1
     263:	r2 = r10
     264:	r2 += -0x10
;   __u32 *value = bpf_map_lookup_elem(&exceed2go_counters, &key);
     265:	r1 = 0x0 ll
     267:	call 0x1
;   if (likely(value)) {
     268:	if r0 == 0x0 goto +0x2 <LBB0_46>
     269:	r1 = 0x1
;     __sync_fetch_and_add(value, 1);
     270:	lock *(u32 *)(r0 + 0x0) += r1

0000000000000878 <LBB0_46>:
;   void *data     = (void *)(unsigned long)ctx->data;
     271:	r2 = *(u32 *)(r9 + 0x0)
;   void *data_end = (void *)(unsigned long)ctx->data_end;
     272:	r1 = *(u32 *)(r9 + 0x4)
;   __u16 ip_pkt_len      = ADJ_LEN + (data_end - data) - ETH_HLEN;
     273:	r1 -= r2
     274:	r1 += 0x22
;   int   tail_len_adjust = IPV6_MTU_MIN - ip_pkt_len;
     275:	r2 = r1
     276:	r2 &= 0xffff
     277:	r7 = 0x500
     278:	r7 -= r2
;   if (tail_len_adjust > 0 && ip_pkt_len % 4) {
     279:	if r2 > 0x4ff goto +0x4 <LBB0_49>
     280:	r1 &= 0x3
;   if (tail_len_adjust > 0 && ip_pkt_len % 4) {
     281:	if r1 == 0x0 goto +0x2 <LBB0_49>
;     tail_len_adjust = -(ip_pkt_len % 4);
     282:	r1 = -r1
     283:	r7 = r1

00000000000008e0 <LBB0_49>:
;   assert_equal(bpf_xdp_adjust_head(ctx, head_len_adjust), 0, XDP_ABORTED);
     284:	r1 = r9
     285:	r2 = 0xffffffd0 ll
     287:	call 0x2c
     288:	r1 = 0x0
;   assert_equal(bpf_xdp_adjust_head(ctx, head_len_adjust), 0, XDP_ABORTED);
     289:	*(u64 *)(r10 - 0x40) = r1
     290:	if r0 != 0x0 goto -0x22 <LBB0_70>
;   if (tail_len_adjust < 0)
     291:	if r7 s> -0x1 goto +0x4 <LBB0_52>
;     assert_equal(bpf_xdp_adjust_tail(ctx, tail_len_adjust), 0, XDP_ABORTED);
     292:	r1 = r9
     293:	r2 = r7
     294:	call 0x41
     295:	if r0 != 0x0 goto -0x27 <LBB0_70>

0000000000000940 <LBB0_52>:
;   data_end = (void *)(unsigned long)ctx->data_end;
     296:	r8 = *(u32 *)(r9 + 0x4)
;   data     = (void *)(unsigned long)ctx->data;
     297:	r6 = *(u32 *)(r9 + 0x0)
;   assert_boundary(orig_ipv6, data_end, XDP_ABORTED);
     298:	r1 = r6
     299:	r1 += 0x66
     300:	if r1 > r8 goto -0x2c <LBB0_70>
     301:	r1 = 0x60
;   bpf_memcpy(ipv6, &ipv6_new, sizeof(struct ipv6hdr) - 2 * IPV6_ALEN);
     302:	*(u32 *)(r6 + 0xe) = r1
     303:	r1 = 0x403a
     304:	*(u16 *)(r6 + 0x14) = r1
;   eth->h_proto = orig_eth->h_proto;
     305:	r1 = *(u16 *)(r6 + 0x3c)
     306:	*(u16 *)(r6 + 0xc) = r1
;   bpf_memcpy(&eth->h_dest, &orig_eth->h_source, ETH_ALEN);
     307:	r1 = *(u16 *)(r6 + 0x3a)
     308:	*(u16 *)(r6 + 0x4) = r1
     309:	r1 = *(u16 *)(r6 + 0x38)
     310:	*(u16 *)(r6 + 0x2) = r1
     311:	r1 = *(u16 *)(r6 + 0x36)
     312:	*(u16 *)(r6 + 0x0) = r1
;   bpf_memcpy(&eth->h_source, &orig_eth->h_dest, ETH_ALEN);
     313:	r1 = *(u16 *)(r6 + 0x34)
     314:	*(u16 *)(r6 + 0xa) = r1
     315:	r1 = *(u16 *)(r6 + 0x32)
     316:	*(u16 *)(r6 + 0x8) = r1
     317:	r1 = *(u16 *)(r6 + 0x30)
     318:	*(u16 *)(r6 + 0x6) = r1
;   struct icmp6hdr *icmp6 = next_header(ipv6);
     319:	r7 = r6
     320:	r7 += 0x36
;   ipv6->payload_len = bpf_htons(data_end - (void *)icmp6);
     321:	r1 = r8
     322:	r1 -= r7
     323:	r1 = be16 r1
     324:	*(u16 *)(r6 + 0x12) = r1
     325:	r2 = *(u64 *)(r10 - 0x38)
;   ipv6->saddr       = *src_addr;
     326:	r1 = *(u64 *)(r2 + 0x8)
     327:	*(u64 *)(r6 + 0x1e) = r1
     328:	r1 = *(u64 *)(r2 + 0x0)
     329:	*(u64 *)(r6 + 0x16) = r1
     330:	r1 = 0x3
;   bpf_memcpy(icmp6, &icmp6_new, sizeof(struct icmp6hdr));
     331:	*(u32 *)(r6 + 0x36) = r1
;   ipv6->daddr       = orig_ipv6->saddr;
     332:	r1 = *(u64 *)(r6 + 0x4e)
     333:	*(u64 *)(r6 + 0x2e) = r1
     334:	r1 = *(u64 *)(r6 + 0x46)
     335:	*(u64 *)(r6 + 0x26) = r1
     336:	r1 = 0x0
;   bpf_memcpy(icmp6, &icmp6_new, sizeof(struct icmp6hdr));
     337:	*(u32 *)(r6 + 0x3a) = r1
;   ipv6->saddr       = *src_addr;
     338:	r3 = r6
     339:	r3 += 0x16
;   sum = bpf_csum_diff(NULL, 0, (void *)&ipv6->saddr, 2 * IPV6_ALEN, sum);
     340:	r2 = 0x0
     341:	r4 = 0x20
     342:	r5 = 0x0
     343:	call 0x1c
     344:	r1 = r0
     345:	r1 <<= 0x20
     346:	r1 >>= 0x20
;   sum = csum_add(sum, ((__u32)ipv6->payload_len) << 16);
     347:	r0 = *(u16 *)(r6 + 0x12)
     348:	r0 <<= 0x10
     349:	r0 <<= 0x20
     350:	r0 >>= 0x20
;   csum += addend;
     351:	r0 += r1
     352:	r3 = r0
     353:	r3 <<= 0x20
     354:	r3 >>= 0x20
     355:	r1 = 0x1
     356:	r2 = 0x1
     357:	if r3 != r0 goto +0x1 <LBB0_55>
     358:	r2 = 0x0

0000000000000b38 <LBB0_55>:
     359:	*(u64 *)(r10 - 0x38) = r6
;   return csum + (csum < addend);
     360:	r0 += r2
     361:	r2 = r0
     362:	r2 <<= 0x20
     363:	r2 >>= 0x20
     364:	r3 = 0xc5ffffff ll
     366:	if r2 > r3 goto +0x1 <LBB0_57>
     367:	r1 = 0x0

0000000000000b80 <LBB0_57>:
;   csum += addend;
     368:	r0 += r1
     369:	r9 = 0x400
;   return csum + (csum < addend);
     370:	r0 += 0x3a000000
     371:	goto +0x4 <LBB0_58>

0000000000000ba0 <LBB0_64>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     372:	r1 &= 0xffff
     373:	r9 = r1
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     374:	if r1 > 0x4 goto +0x1 <LBB0_58>
     375:	goto +0x18 <LBB0_73>

0000000000000bc0 <LBB0_58>:
;     __u16 j = (i >= 512) ? 512 : i;
     376:	r4 = r9
     377:	r4 <<= 0x20
     378:	r4 >>= 0x20
     379:	r1 = 0x200
     380:	if r1 > r4 goto +0x1 <LBB0_60>
     381:	r4 = 0x200

0000000000000bf0 <LBB0_60>:
;     if (likely(buf + j <= data_end)) {
     382:	r6 = r7
     383:	r6 += r4
     384:	if r6 > r8 goto +0x6 <LBB0_62>
;       sum = bpf_csum_diff(NULL, 0, buf, j, sum);
     385:	r1 = 0x0
     386:	r2 = 0x0
     387:	r3 = r7
     388:	r5 = r0
     389:	call 0x1c
     390:	r7 = r6

0000000000000c38 <LBB0_62>:
;   for (__u16 i = 1024; i > 4; i = (i > 512) ? (i - 512) : i >> 1) {
     391:	r1 = r9
     392:	r1 += 0xfe00
     393:	r2 = r9
     394:	r2 <<= 0x20
     395:	r2 >>= 0x20
     396:	if r2 > 0x200 goto -0x19 <LBB0_64>
     397:	r9 >>= 0x1
     398:	r1 = r9
     399:	goto -0x1c <LBB0_64>

0000000000000c80 <LBB0_73>:
;   if (likely(buf + 4 <= data_end)) {
     400:	r1 = r7
     401:	r1 += 0x4
     402:	r4 = *(u64 *)(r10 - 0x38)
     403:	if r1 > r8 goto +0xc <LBB0_68>
;     sum = csum_add(sum, *(__be32 *)buf++);
     404:	r1 = *(u32 *)(r7 + 0x0)
;   csum += addend;
     405:	r0 <<= 0x20
     406:	r0 >>= 0x20
     407:	r1 += r0
     408:	r3 = r1
     409:	r3 <<= 0x20
     410:	r3 >>= 0x20
     411:	r2 = 0x1
     412:	if r3 != r1 goto +0x1 <LBB0_67>
     413:	r2 = 0x0

0000000000000cf0 <LBB0_67>:
;   return csum + (csum < addend);
     414:	r1 += r2
     415:	r0 = r1

0000000000000d00 <LBB0_68>:
     416:	r1 = 0xffff0000 ll
;   sum = (sum & 0xffff) + (sum >> 16);
     418:	r2 = r0
     419:	r2 &= r1
     420:	r2 >>= 0x10
     421:	r0 &= 0xffff
     422:	r0 += r2
;   sum = (sum & 0xffff) + (sum >> 16);
     423:	r1 = r0
     424:	r1 >>= 0x10
     425:	r1 += r0
;   icmp6->icmp6_cksum = ~csum_fold(icmp6_csum(icmp6, ipv6, data_end, true));
     426:	r1 ^= -0x1
     427:	*(u16 *)(r4 + 0x38) = r1
     428:	goto -0xae <LBB0_69>
